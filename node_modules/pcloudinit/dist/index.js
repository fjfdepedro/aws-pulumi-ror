"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("async-file");
const mustache = require("mustache");
// createUserData produces a cloud-init payload, suitable for user data, out of the given init structure.
function createUserData(configs, init) {
    return __awaiter(this, void 0, void 0, function* () {
        // We need to encode the user data into multiple MIME parts. This ensures that all of the pieces are processed
        // correctly by the cloud-init system, without needing to do map merging, etc.
        const boundary = "cd4621d39f783ba4";
        let result = `Content-Type: multipart/mixed; ` +
            `Merge-Type: list(append)+dict(recurse_array)+str(); ` +
            `boundary="${boundary}"\n` +
            `MIME-Version: 1.0\r\n\r\n`;
        // For each config entry, generate the cloud-init statements to carry out its wishes.
        for (let name of configs) {
            let config = init[name];
            if (!config) {
                throw new Error(`Missing config entry for ${name}`);
            }
            result += `--${boundary}\nContent-Type: text/cloud-config\r\n\r\n`;
            result += `merge_how: list(append)+dict(recurse_array)+str()\n`;
            // Process the sections in the same order as cfn-init; from:
            // https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-init.html:
            //
            //     "The cfn-init helper script processes these configuration sections in the following order: packages,
            //      groups, users, sources, files, commands, and then services. If you require a different order, separate
            //      your sections into different config keys, and then use a configset that specifies the order in which the
            //      config keys should be processed."
            //
            // TODO: support for groups, users, and sources.
            if (config.packages && Object.keys(config.packages).length) {
                // Install package manager packages:
                result += `update_packages: true\n`;
                result += `packages:\n`;
                for (let manager of Object.keys(config.packages)) {
                    let packages = config.packages[manager];
                    switch (manager) {
                        case "yum":
                            for (let pkg of packages) {
                                result += `- ${pkg}\n`;
                            }
                            break;
                        default:
                            // TODO: support more package managers.
                            throw new Error(`Unrecognized package manager: ${manager}`);
                    }
                }
            }
            if (config.files && Object.keys(config.files).length) {
                // Emit files with the appropriate content and permissions:
                result += `write_files:\n`;
                for (let path of Object.keys(config.files)) {
                    let file = config.files[path];
                    result += `- path: ${path}\n`;
                    result += `  encoding: b64\n`;
                    result += `  content: ${Buffer.from(yield file.content).toString("base64")}\n`;
                    result += `  owner: ${file.owner}:${file.group}\n`;
                    result += `  permissions: '${file.mode}'\n`;
                }
            }
            let commands = config.commands || {};
            if (config.services && Object.keys(config.services).length) {
                for (let manager of Object.keys(config.services)) {
                    // Expand out service management into commands, as there is no built-in cloud-init equivalent:
                    let services = config.services[manager];
                    switch (manager) {
                        case "sysvinit":
                            for (let service of Object.keys(services)) {
                                let serviceInfo = services[service];
                                if (serviceInfo.enabled) {
                                    commands[`${manager}-${service}-enabled`] = {
                                        command: `chkconfig ${service} on`,
                                    };
                                }
                                if (serviceInfo.ensureRunning) {
                                    commands[`${manager}-${service}-ensureRunning`] = {
                                        command: `service ${service} start`,
                                    };
                                }
                            }
                            break;
                        default:
                            // TODO: support more service managers.
                            throw new Error(`Unrecognized service manager: ${manager}`);
                    }
                }
            }
            if (commands && Object.keys(commands).length) {
                // Invoke commands as they are encountered:
                result += `runcmd:\n`;
                for (let command of Object.keys(commands)) {
                    let entry = commands[command];
                    result += `- ${entry.command}\n`;
                    if (entry.test) {
                        result += `- ${entry.test}\n`;
                    }
                }
            }
        }
        result += `--${boundary}--`;
        return result;
    });
}
exports.createUserData = createUserData;
// renderConfigFile renders a given file using mustache and a config bag.
function renderConfigFile(path, config) {
    return __awaiter(this, void 0, void 0, function* () {
        return mustache.render(yield fs.readFile(path, "utf8"), config);
    });
}
exports.renderConfigFile = renderConfigFile;
